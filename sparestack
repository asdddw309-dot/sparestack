local startTime = tick()
local placeId = game.PlaceId
local fluentUrl = placeId == 14386691987 and "https://raw.githubusercontent.com/discoart/FluentPlus/refs/heads/main/Beta.lua" or
                  placeId == 17652855195 and "https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua" or nil
if not fluentUrl then
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Unsupported Game", Text = "This script only supports PlaceIDs 14386691987 and 17652855195", Duration = 5})
    return
end

local Fluent = loadstring(game:HttpGet(fluentUrl, true))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local Knit = require(game.ReplicatedStorage.Packages.Knit)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local localPlayer = Players.LocalPlayer
local ControlServiceRE, StartShoot, Shoot, AFKToggle
local sphereVisible = true

local function initializeControlServiceRE()
    for i = 1, 5 do
        local success, controlResult = pcall(function()
            local controlService = ReplicatedStorage.Packages.Knit.Services.ControlService.RE
            return {StartShoot = controlService.StartShoot, Shoot = controlService.Shoot}
        end)
        if success and controlResult then
            ControlServiceRE = ReplicatedStorage.Packages.Knit.Services.ControlService.RE
            StartShoot = controlResult.StartShoot
            Shoot = controlResult.Shoot
            return true
        end
        task.wait(0.5)
    end
    Fluent:Notify({Title = "Auto Green Error", Content = "ControlService RemoteEvents not found after retries, skipping Auto Green feature.", Duration = 5})
    return false
end

local function initializeAFKToggle()
    for i = 1, 5 do
        local success, afkResult = pcall(function()
            return ReplicatedStorage.Packages.Knit.Services.PlayerService.RE.AFKToggle
        end)
        if success and afkResult then
            AFKToggle = afkResult
            return true
        end
        task.wait(0.5)
    end
    Fluent:Notify({Title = "AFK Toggle Error", Content = "AFKToggle RemoteEvent not found after retries, skipping AFK feature.", Duration = 5})
    return false
end

local function initializeKnit()
    local success, err = pcall(function()
        Knit.Start()
        task.wait(1)
    end)
    if not success then
        Fluent:Notify({Title = "Knit Error", Content = "Failed to initialize Knit: " .. tostring(err), Duration = 5})
    end
end

initializeKnit()
local controlSuccess = initializeControlServiceRE()
local afkSuccess = placeId == 14386691987 and initializeAFKToggle() or false

local Window = Fluent:CreateWindow({
    Title = "Spare Stack",
    SubTitle = "Premium | Beta Testing",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Home = Window:AddTab({Title = "Home", Icon = "home"}),
    Player = Window:AddTab({Title = "Player", Icon = "user"}),
    Visual = Window:AddTab({Title = "Visual", Icon = "eye"}),
    Automation = Window:AddTab({Title = "Automation", Icon = "cpu"})
}

-- Add Misc tab before Settings if PlaceId is 14386691987
if placeId == 14386691987 then
    Tabs.Misc = Window:AddTab({Title = "Misc", Icon = "more-horizontal"})
end

-- Add Settings tab last
Tabs.Settings = Window:AddTab({Title = "Settings", Icon = "settings"})

local Options = Fluent.Options
local loadTime = tick() - startTime
Fluent:Notify({Title = "Spare Stack Loaded", Content = string.format("Script loaded in %.2f seconds", loadTime), Duration = 10})
task.wait(0.5)
Fluent:Notify({Title = "Welcome Back", Content = "Premium user", Duration = 10})

if controlSuccess then
    local autoGreenEnabled = false
    local autoGreenMode = "Blatant"

    local function runShootingSequence()
        StartShoot:FireServer()
        task.wait(autoGreenMode == "Legit" and 0.5 or 0.21)
        Shoot:FireServer(autoGreenMode == "Legit" and 0.98 or 1)
        task.wait(0.20)
        Shoot:FireServer(0)
    end

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not autoGreenEnabled or input.KeyCode ~= Enum.KeyCode.E then return end
        task.spawn(runShootingSequence)
    end)

    Tabs.Home:AddToggle("AutoGreenToggle", {Title = "Enable Auto Green (E key)", Default = false}):OnChanged(function(state)
        autoGreenEnabled = state
    end)

    Tabs.Home:AddDropdown("AutoGreenModeDropdown", {
        Title = "Auto Green Mode",
        Values = {"Blatant", "Legit (3 Great, 2 Perfect)"},
        Default = 1,
        Callback = function(value)
            autoGreenMode = value == "Legit (3 Great, 2 Perfect)" and "Legit" or "Blatant"
        end
    })
end

Tabs.Automation:AddToggle("AutoPlayToggle", {
    Title = "Auto Play",
    Default = false,
    Callback = function(state)
        if state then
            Fluent:Notify({Title = "In the making", Content = "Im still working on this, sorry", Duration = 10})
        else
            print("-------")
        end
    end
})

local TOGGLE_KEY = Enum.KeyCode.T
local MIN_PREDICT = 3
local MAX_PREDICT = 8
local autoGuardEnabled = false
local autoGuardActive = false
local predictionSphere
local targetPlayer
local lastToggleTime = 0
local TOGGLE_DEBOUNCE = 0.1
local predictionMultiplier = 0.2
local predictionMode = "Velocity-Based"
local fixedDistance = 3
local sphereSize = 2
local sphereColor = Color3.new(1, 0, 0)
local AUTO_SWITCH_DISTANCE = 5
local NOTIFICATION_DEBOUNCE = 0.5
local sliderNotifyTask

local function createSphere()
    local sphere = Instance.new("Part")
    sphere.Name = "PredictionSphere"
    sphere.Shape = Enum.PartType.Ball
    sphere.Size = Vector3.new(sphereSize, sphereSize, sphereSize)
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.Material = Enum.Material.ForceField
    sphere.Color = sphereColor
    sphere.Transparency = sphereVisible and 0.3 or 1
    sphere.Parent = Workspace
    return sphere
end

local function fadeSphere(sphere, targetTransparency, duration)
    if not sphere or not sphereVisible then return end
    local success, err = pcall(function()
        local start = sphere.Transparency
        local elapsed = 0
        local conn = RunService.RenderStepped:Connect(function(dt)
            if not sphere or not sphere.Parent then
                conn:Disconnect()
                return
            end
            elapsed = elapsed + dt
            local alpha = math.clamp(elapsed / duration, 0, 1)
            sphere.Transparency = start + (targetTransparency - start) * alpha
            if alpha >= 1 then
                conn:Disconnect()
            end
        end)
    end)
    if not success then
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard Error", Text = "Failed to fade sphere: " .. tostring(err), Duration = 5})
    end
end

local function getClosestPlayer()
    local character = localPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local closest, closestDist = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local char = player.Character
            local targetHRP = char and char:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local dist = (hrp.Position - targetHRP.Position).Magnitude
                if dist < closestDist then
                    closest = player
                    closestDist = dist
                end
            end
        end
    end
    return closest
end

local function checkForNewTarget()
    if targetMode == "Stay Locked" or not predictionSphere then return targetPlayer end
    local character = localPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then return targetPlayer end
    local closest, closestDist = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player ~= targetPlayer then
            local char = player.Character
            local targetHRP = char and char:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local dist = (predictionSphere.Position - targetHRP.Position).Magnitude
                if dist < AUTO_SWITCH_DISTANCE and dist < closestDist then
                    closest = player
                    closestDist = dist
                end
            end
        end
    end
    return closest or targetPlayer
end

local function toggleAutoGuard()
    if not autoGuardEnabled then return end
    local currentTime = tick()
    if currentTime - lastToggleTime < TOGGLE_DEBOUNCE then return end
    lastToggleTime = currentTime
    autoGuardActive = not autoGuardActive
    local success, err = pcall(function()
        if autoGuardActive then
            if not predictionSphere then predictionSphere = createSphere() end
            if sphereVisible then fadeSphere(predictionSphere, 0.3, 0.3) end
            targetPlayer = getClosestPlayer()
            StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Enabled", Duration = 3})
        else
            if predictionSphere then
                if sphereVisible then fadeSphere(predictionSphere, 1, 0.3) end
                task.delay(0.3, function()
                    if not autoGuardActive and predictionSphere then
                        predictionSphere:Destroy()
                        predictionSphere = nil
                    end
                end)
            end
            targetPlayer = nil
            StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Disabled", Duration = 3})
        end
    end)
    if not success then
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard Error", Text = "Toggle failed: " .. tostring(err), Duration = 5})
    end
end

RunService.RenderStepped:Connect(function()
    if not autoGuardEnabled or not autoGuardActive then return end
    local success, err = pcall(function()
        targetPlayer = checkForNewTarget()
        if not targetPlayer then
            if predictionSphere then predictionSphere.Transparency = sphereVisible and 0.3 or 1 end
            return
        end
        local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then
            if predictionSphere then predictionSphere.Transparency = sphereVisible and 0.3 or 1 end
            return
        end
        local character = localPlayer.Character
        if not character then
            if predictionSphere then predictionSphere.Transparency = sphereVisible and 0.3 or 1 end
            return
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp then
            if predictionSphere then predictionSphere.Transparency = sphereVisible and 0.3 or 1 end
            return
        end
        local predictedPosition
        local velocity = targetHRP.AssemblyLinearVelocity
        local lookVector = targetHRP.CFrame.LookVector
        local isMovingBackward = velocity.Magnitude > 0 and velocity.Unit:Dot(lookVector) < -0.5
        if predictionMode == "Velocity-Based" and not isMovingBackward then
            local direction = velocity.Magnitude > 0 and velocity.Unit or lookVector
            local predictionDistance = math.clamp(velocity.Magnitude * predictionMultiplier, MIN_PREDICT, MAX_PREDICT)
            predictedPosition = targetHRP.Position + direction * predictionDistance
        else
            predictedPosition = targetHRP.Position + lookVector * fixedDistance
        end
        if predictionSphere then
            predictionSphere.Position = predictedPosition
            predictionSphere.Size = Vector3.new(sphereSize, sphereSize, sphereSize)
            predictionSphere.Color = sphereColor
            predictionSphere.Transparency = sphereVisible and 0.3 or 1
        end
        humanoid:MoveTo(predictedPosition)
    end)
    if not success then
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard Error", Text = "Update failed: " .. tostring(err), Duration = 5})
    end
end)

local walkspeedEnabled = false
local walkspeedValue = 16
local moveConnection

local function updateWalkspeed()
    if moveConnection then moveConnection:Disconnect() end
    if not walkspeedEnabled then return end
    moveConnection = RunService.Heartbeat:Connect(function(dt)
        local character = localPlayer.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not (humanoidRootPart and humanoid) then return end
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0 then
            humanoidRootPart.CFrame += moveDirection.Unit * walkspeedValue * dt
        end
    end)
end

Tabs.Player:AddToggle("WalkspeedToggle", {Title = "Enable Walkspeed", Default = false}):OnChanged(function(state)
    walkspeedEnabled = state
    updateWalkspeed()
end)

Tabs.Player:AddSlider("WalkspeedSlider", {Title = "Walkspeed Value", Min = 1, Max = 200, Default = 16, Rounding = 0}):OnChanged(function(value)
    walkspeedValue = value
end)

local hitboxEnabled = false
local hitboxRadius = 10
local hitboxConnection

local function simulateTouch(ball, rootPart)
    firetouchinterest(rootPart, ball, 0)
    task.wait()
    firetouchinterest(rootPart, ball, 1)
end

local function updateHitbox()
    if hitboxConnection then hitboxConnection:Disconnect() end
    if not hitboxEnabled then return end
    hitboxConnection = RunService.Heartbeat:Connect(function()
        local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        for _, ball in ipairs(Workspace:GetChildren()) do
            if ball:IsA("BasePart") and ball.Name == "Basketball" then
                if (ball.Position - rootPart.Position).Magnitude <= hitboxRadius then
                    task.spawn(simulateTouch, ball, rootPart)
                end
            end
        end
    end)
end

Tabs.Player:AddToggle("BallMagnetsToggle", {Title = "Enable Ball Magnets", Default = false}):OnChanged(function(state)
    hitboxEnabled = state
    updateHitbox()
end)

Tabs.Player:AddSlider("BallMagnetsSlider", {Title = "Ball Magnets Radius", Min = 1, Max = 18, Default = 10, Rounding = 0}):OnChanged(function(value)
    hitboxRadius = value
end)

Tabs.Player:AddToggle("AutoGuardToggle", {Title = "Enable Auto Guard", Default = false}):OnChanged(function(state)
    autoGuardEnabled = state
    if not state then
        autoGuardActive = false
        local success, err = pcall(function()
            if predictionSphere then
                if sphereVisible then fadeSphere(predictionSphere, 1, 0.3) end
                task.delay(0.3, function()
                    if not autoGuardActive and predictionSphere then
                        predictionSphere:Destroy()
                        predictionSphere = nil
                    end
                end)
            end
            targetPlayer = nil
        end)
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Disabled", Duration = 3})
        if not success then
            StarterGui:SetCore("SendNotification", {Title = "Auto Guard Error", Text = "Disable failed: " .. tostring(err), Duration = 5})
        end
    else
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Enabled", Duration = 3})
    end
end)

Tabs.Player:AddKeybind("AutoGuardKeybind", {
    Title = "Auto Guard Keybind",
    Description = "Press a key to toggle Auto Guard",
    Mode = "Toggle",
    Default = "T",
    Callback = function(value)
        if autoGuardEnabled then toggleAutoGuard() end
    end,
    ChangedCallback = function(new)
        TOGGLE_KEY = new
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard Keybind", Text = "Keybind set to " .. tostring(new), Duration = 3})
    end
})

Tabs.Player:AddDropdown("TargetModeDropdown", {
    Title = "Auto Guard Target Mode",
    Values = {"Stay Locked", "Auto Switch"},
    Default = 1,
    Callback = function(value)
        targetMode = value
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Target mode set to " .. value, Duration = 3})
    end
})

Tabs.Player:AddDropdown("PredictionMultiplierDropdown", {
    Title = "Prediction Distance Multiplier",
    Description = "This is for Velocity-Based mode",
    Values = {"Low (0.1)", "Medium (0.2)", "High (0.4)"},
    Default = 2,
    Callback = function(value)
        predictionMultiplier = value == "Low (0.1)" and 0.1 or value == "Medium (0.2)" and 0.2 or 0.4
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Prediction multiplier set to " .. value, Duration = 3})
    end
})

Tabs.Player:AddDropdown("PredictionModeDropdown", {
    Title = "Prediction Mode",
    Values = {"Velocity-Based", "Fixed Distance"},
    Default = 1,
    Callback = function(value)
        predictionMode = value
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Prediction mode set to " .. value, Duration = 3})
    end
})

Tabs.Player:AddSlider("FixedDistanceSlider", {
    Title = "Fixed Prediction Distance",
    Description = "Distance (studs) for Fixed Distance mode",
    Min = 1,
    Max = 10,
    Default = 3,
    Rounding = 1
}):OnChanged(function(value)
    fixedDistance = value
    if sliderNotifyTask then task.cancel(sliderNotifyTask) end
    sliderNotifyTask = task.delay(NOTIFICATION_DEBOUNCE, function()
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Fixed prediction distance set to " .. value .. " studs", Duration = 3})
        sliderNotifyTask = nil
    end)
end)

Tabs.Player:AddDropdown("SphereSizeDropdown", {
    Title = "Sphere Size",
    Values = {"Small (1 stud)", "Medium (2 studs)", "Large (4 studs)"},
    Default = 2,
    Callback = function(value)
        sphereSize = value == "Small (1 stud)" and 1 or value == "Medium (2 studs)" and 2 or 4
        if predictionSphere then predictionSphere.Size = Vector3.new(sphereSize, sphereSize, sphereSize) end
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Sphere size set to " .. value, Duration = 3})
    end
})

Tabs.Player:AddDropdown("SphereColorDropdown", {
    Title = "Sphere Color",
    Values = {"Red", "Green", "Blue", "Custom"},
    Default = 1,
    Callback = function(value)
        if value == "Custom" then return end
        sphereColor = value == "Red" and Color3.new(1, 0, 0) or value == "Green" and Color3.new(0, 1, 0) or Color3.new(0, 0, 1)
        if predictionSphere then predictionSphere.Color = sphereColor end
        StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Sphere color set to " .. value, Duration = 3})
    end
})

Tabs.Player:AddColorpicker("SphereColorPicker", {
    Title = "Custom Sphere Color",
    Default = Color3.new(1, 0, 0),
    Callback = function(value)
        if Options.SphereColorDropdown.Value == "Custom" then
            sphereColor = value
            if predictionSphere then predictionSphere.Color = sphereColor end
            StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Custom sphere color set", Duration = 3})
        end
    end
})

Tabs.Visual:AddToggle("SphereVisibilityToggle", {Title = "Show Prediction Sphere", Default = true}):OnChanged(function(state)
    sphereVisible = state
    if predictionSphere then predictionSphere.Transparency = sphereVisible and 0.3 or 1 end
    StarterGui:SetCore("SendNotification", {Title = "Auto Guard", Text = "Prediction sphere " .. (state and "visible" or "hidden"), Duration = 3})
end)

if afkSuccess then
    Tabs.Misc:AddButton({
        Title = "Toggle AFK",
        Callback = function()
            AFKToggle:FireServer(true)
            StarterGui:SetCore("SendNotification", {Title = "AFK Toggle", Text = "AFK status toggled", Duration = 3})
        end
    })
end

if placeId == 14386691987 then
    Tabs.Misc:AddButton({
        Title = "Unlock Zoom",
        Callback = function()
            localPlayer.CameraMaxZoomDistance = 1000
            StarterGui:SetCore("SendNotification", {Title = "Unlock Zoom", Text = "Zoom unlocked", Duration = 3})
        end
    })

    Tabs.Misc:AddButton({
        Title = "Show Records",
        Callback = function()
            for _, character in ipairs(Workspace:GetChildren()) do
                if character:IsA("Model") and Players:GetPlayerFromCharacter(character) then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        local infoGui = humanoidRootPart:FindFirstChild("Info")
                        if infoGui and infoGui:IsA("BillboardGui") then
                            infoGui.Enabled = true
                            for _, item in ipairs(infoGui:GetChildren()) do
                                if item:IsA("Frame") then item.Visible = true end
                            end
                        end
                    end
                end
            end
            StarterGui:SetCore("SendNotification", {Title = "Show Records", Text = "Player records made visible", Duration = 3})
        end
    })

    Tabs.Misc:AddButton({
        Title = "Rank Bypass",
        Callback = function()
            Knit.GetService("PlayerService").Teleport:Fire("Ranked")
            StarterGui:SetCore("SendNotification", {Title = "Rank Bypass", Text = "Teleport to Ranked initiated", Duration = 3})
        end
    })
end

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:BuildConfigSection(Tabs.Settings)
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
